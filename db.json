{
  "blogs": [
    {
      "id": "dd23",
      "title": "Snappy UI Optimization with useDeferredValue",
      "content": "Over the years, React has given us a number of tools for optimizing the performance of our applications. One of the most powerful hidden gems is useDeferredValue. It can have a tremendous impact on user experience in certain situations! ‚ö°\n\nI recently used this hook to fix a gnarly performance issue on this blog, and it sorta blew my mind. The improvement on low-end devices felt illegal, like black magic.\n\nuseDeferredValue has a bit of an intimidating reputation, and it is a pretty sophisticated tool, but it isn‚Äôt too scary with the right mental model. In this tutorial, I‚Äôll show you exactly how it works, and how you can use it to dramatically improve the performance of your applications.s",
      "updatedAt": "2026-02-06T16:56:36.387Z"
    },
    {
      "id": "fc9c",
      "title": "CSS in React Server Components",
      "content": "\nTable of Contents\nIntroduction\nBreaking down React Server Components\nServer Components are limited\nHow CSS-in-JS libraries work\nThe Crux of the Problem\nThe World of Zero-Runtime CSS-in-JS Libraries\nLinaria\nPanda CSS\nPigment CSS\nThe list goes on\nThe path forward\nWhat I'm doing\n\"Like\" this post\n30.380\nIntroduction\nOn May 4th, 2023, Vercel announced the stable release of Next 13.4, becoming the first React framework to be built on top of React Server Components.\n\nThis is a big deal! RSC (React Server Components) gives us an official way to write server-exclusive code in React. It opens a lot of interesting new doors, as I wrote about in my blog post, Making Sense of RSC.\n\nBut you can't make an omelette without cracking a few eggs. RSC is a fundamental change to how React works, and some of the libraries and tools we've been using have gotten‚Ä¶ scrambled üòÖ. For those of us who use libraries like styled-components/Emotion, there hasn‚Äôt been a clear path forward.\n\nOver the past few months, I‚Äôve been digging into this, building an understanding of the compatibility issues, and learning about what the options are. At this point, I feel like I have a pretty solid grasp on the whole situation. I‚Äôve also discovered some pretty exciting developments that have been flying under the radar. ‚ú®\n\nIf you use a CSS-in-JS library, my hope is that this blog post will help clear away a lot of confusion, and give you some practical options for what to do.\n\nJust use __________.\nWhen this discussion comes up online, one of the most common suggestions is to switch to a different CSS tool. After all, there are no shortage of options in the React ecosystem!\n\nFor many of us, though, this isn't a practical suggestion. I have more than 5,000 styled components across my blog and course platform. Migrating to an entirely different tool is much easier said than done.\n\nAnd honestly, even if I could snap my fingers and swap in a totally different library, I wouldn't want to. I really like the styled API!\n\nLater in this blog post, we will discuss some alternative CSS libraries, but we‚Äôll focus on options with similar APIs to styled-components.\n\nLink to this headingBreaking down React Server Components\nIn order to understand the compatibility issue, we need to understand React Server Components. Before we can talk about that, though, we need to make sure that we understand Server Side Rendering (SSR).\n\nSSR is an umbrella term that comprises several different strategies and implementations, but the most typical version of it looks like this:",
      "updatedAt": "2026-02-06T15:46:59.323Z"
    },
    {
      "id": "9024",
      "title": "Making Sense of React Server Components",
      "content": "\nTable of Contents\nIntroduction\nA quick primer on Server Side Rendering\nBouncing back and forth\nIntroduction to React Server Components\nCompatible Environments\nSpecifying client components\nBoundaries\nWorkarounds\nPeeking under the hood\nAdvantages\nThe full picture\n\"Like\" this post\n138.421\nIntroduction\nSo, here's something that makes me feel old: React celebrated its 10th birthday this year!\n\nIn the decade since React was first introduced to a bewildered dev community, it‚Äôs gone through several evolutions. The React team has not been shy when it comes to radical changes: if they discover a better solution to a problem, they'll run with it.\n\nA couple of months ago, the React team unveiled React Server Components, the latest paradigm shift. For the first time ever, React components can run exclusively on the server.\n\nThere's been so much friggin‚Äô confusion about this online. Lots of folks have lots of questions around what this is, how it works, what the benefits are, and how it fits together with things like Server Side Rendering.\n\nI've been doing a lot of experimentation with React Server Components, and I've answered a lot of my own questions. I have to admit, I'm way more excited about this stuff than I expected to be. It's really cool!\n\nSo, my goal today is to help demystify this stuff for you, to answer a lot of the questions you might have about React Server Components!\n\nIntended audience\nThis tutorial is written primarily for developers who are already using React, and who are curious about React Server Components. You don't need to be a React expert, but it will likely be pretty confusing if you're just getting started with React.\n\nLink to this headingA quick primer on Server Side Rendering\nTo put React Server Components in context, it's helpful to understand how Server Side Rendering (SSR) works. If you're already familiar with SSR, feel free to skip to the next heading!\n\nWhen I first started using React in 2015, most React setups used a ‚Äúclient-side‚Äù rendering strategy. The user would receive an HTML file that looked like this:\n\n\n<!DOCTYPE html>\n<html>\n  <body>\n    <div id=\"root\"></div>\n    <script src=\"/static/js/bundle.js\"></script>\n  </body>\n</html>\nThat bundle.js script includes everything we need to mount and run the application, including React, other third-party dependencies, and all of the code we've written.\n\nOnce the JS has been downloaded and parsed, React springs into action, conjuring all of the DOM nodes for our entire application, and housing it in that empty <div id=\"root\">.\n\nThe problem with this approach is that it takes time to do all of that work. And while it's all happening, the user is staring at a blank white screen. This problem tends to get worse over time: every new feature we ship adds more kilobytes to our JavaScript bundle, prolonging the amount of time that the user has to sit and wait.*\n\nServer Side Rendering was designed to improve this experience. Instead of sending an empty HTML file, the server will render our application to generate the actual HTML. The user receives a fully-formed HTML document.\n\nThat HTML file will still include the <script> tag, since we still need React to run on the client, to handle any interactivity. But we configure React to work a little bit differently in-browser: instead of conjuring all of the DOM nodes from scratch, it instead adopts the existing HTML. This process is known as hydration.\n\nI like the way React core team member Dan Abramov explains this:\n\nHydration is like watering the ‚Äúdry‚Äù HTML with the ‚Äúwater‚Äù of interactivity and event handlers.\n\nOnce the JS bundle has been downloaded, React will quickly run through our entire application, building up a virtual sketch of the UI, and ‚Äúfitting‚Äù it to the real DOM, attaching event handlers, firing off any effects, and so on.\n\nAnd so, that's SSR in a nutshell. A server generates the initial HTML so that users don't have to stare at an empty white page while the JS bundles are downloaded and parsed. Client-side React then picks up where server-side React left off, adopting the DOM and sprinkling in the interactivity.",
      "updatedAt": "2026-02-06T15:48:07.807Z"
    },
    {
      "id": "e569",
      "title": "Why React Re-Renders",
      "content": "\nTable of Contents\nIntroduction\nThe core React loop\nIt's not about the props\nCreating pure components\nWhat about context?\nProfiling with the React Devtools\nHighlighting re-renders\nGoing deeper\nBonus: Performance tips\n\"Like\" this post\n124.898\nIntroduction\nSo, I'll be honest. I had been working professionally with React for years without really understanding how React's re-rendering process worked. üòÖ\n\nI think this is true for lots of React developers. We understand enough to get by, but if you ask a group of React developers a question like ‚ÄúWhat triggers a re-render in React?‚Äù, you'll likely get a handful of different hand-wavy answers.\n\nThere are a lot of misconceptions out there about this topic, and it can lead to a lot of uncertainty. If we don't understand React's render cycle, how can we understand how to use React.memo, or when we should wrap our functions in useCallback??\n\nIn this tutorial, we're going to build a mental model for when and why React re-renders. We'll also learn how to tell why a specific component re-rendered, using the React devtools.",
      "updatedAt": "2026-02-06T15:57:59.077Z"
    },
    {
      "id": "105e",
      "title": "Brand New Layouts with CSS Subgrid",
      "content": "\nWhen CSS Grid layout was first released, it came with a big asterisk: only the grid‚Äôs direct children could participate in the layout. ‚ÄúSubgrid‚Äù is a newer addition to CSS Grid which allows us to extend the grid layout down through the DOM tree.\n\nWhen I first heard about subgrid, it seemed to me like a convenience, a way to make it a bit simpler to accomplish the same stuff I was already doing. As it turns out, subgrid is way more interesting than that. It opens whole new doors in terms of the UIs we can build!\n\nIn this tutorial, I‚Äôll show you some of the exciting new things we can do with subgrid. Along the way, you‚Äôll learn the basic mechanics of subgrid. We‚Äôll even go over the most common gotchas!\n\nIntended audience\nThis blog post assumes that you understand the basics of CSS Grid layout. If you‚Äôre not super comfortable with grid, you can learn the fundamentals here:\n\nAn Interactive Guide to CSS Grid\nCredit to Kevin Powell\nIn preparation for this tutorial, I looked at a lot of subgrid resources, to try to see what sorts of things people were building with subgrid. The best examples I found, by far, are from YouTube superstar (and fellow Canadian!) Kevin Powell(opens in new tab). Specifically, these videos helped shape the examples we cover in this post:\n\n‚ÄúEasy and more consistent layouts using subgrid‚Äù(opens in new tab)\n‚ÄúYou can't do this without subgrid‚Äù(opens in new tab)\n‚ÄúThe dichotomy of grid‚Äù(opens in new tab)\nLink to this headingThe fundamentals\nWe‚Äôll get to the interesting stuff soon, but first, let‚Äôs start with the basics.\n\nSuppose we want to implement the following mockup:",
      "updatedAt": "2026-02-06T16:17:24.540Z"
    }
  ],
  "comments": [
    {
      "id": "1",
      "body": "some comment",
      "postId": 1
    }
  ],
  "profile": {
    "name": "typicode"
  }
}